"""
Module de gestion des prix de r√©f√©rence
Import depuis Excel/CSV et comparaison avec les factures
"""

import pandas as pd
import json
import os
from typing import Dict, List, Any, Optional
from datetime import datetime
import logging
import re

logger = logging.getLogger(__name__)

# === Firestore ===
try:
    from modules.firestore_db import available as _fs_available, get_client as _fs_client
except Exception:
    # Import l√©ger pour √©viter ImportError si Firestore non configur√©
    def _fs_available():
        return False
    def _fs_client():
        return None

class PriceManager:
    """Gestionnaire des prix de r√©f√©rence (Firestore uniquement)"""
    
    def __init__(self):
        """Initialiser le gestionnaire de prix (Firestore uniquement)"""
        # üî• FIRESTORE UNIQUEMENT - Plus de fichiers locaux
        self._fs_enabled = False
        self._fs = None
        
        # Initialiser Firestore
        try:
            from modules.firestore_db import FirestoreDB
            firestore_db = FirestoreDB()
            self._fs = firestore_db.db
            self._fs_enabled = True
            print("‚úÖ Firestore initialis√© pour PriceManager")
        except Exception as e:
            print(f"‚ùå Erreur initialisation Firestore PriceManager: {e}")
            self._fs_enabled = False
            self._fs = None
    
    def is_connected(self) -> bool:
        """V√©rifier si Firestore est accessible"""
        return self._fs_enabled and self._fs is not None
    
    def get_all_prices(self, page: int = 1, per_page: int = 50, 
                      search: str = '', supplier: str = '', restaurant_name: str = None) -> Dict[str, Any]:
        """R√©cup√©rer tous les prix de r√©f√©rence depuis Firestore uniquement"""
        try:
            if not self._fs_enabled:
                return {
                    'items': [],
                    'total': 0,
                    'page': page,
                    'pages': 1,
                    'per_page': per_page,
                    'error': 'Firestore non disponible'
                }
            
            # Construire la requ√™te Firestore
            query = self._fs.collection('prices')
            
            # Appliquer les filtres
            if supplier:
                query = query.where('fournisseur', '==', supplier)
            
            if restaurant_name:
                # Filtrer par restaurant OU prix g√©n√©raux
                # Note: Firestore ne supporte pas les requ√™tes OR complexes
                # On va filtrer c√¥t√© application
                pass
            
            # R√©cup√©rer tous les documents
            docs = list(query.stream())
            
            # Convertir en liste de dictionnaires
            items = []
            for doc in docs:
                data = doc.to_dict()
                data['id'] = doc.id
                items.append(data)
            
            # Appliquer les filtres c√¥t√© application
            if restaurant_name:
                items = [item for item in items if 
                        item.get('restaurant') == restaurant_name or 
                        item.get('restaurant') == 'G√©n√©ral' or 
                        not item.get('restaurant')]
            
            if search:
                search_lower = search.lower()
                items = [item for item in items if 
                        search_lower in item.get('produit', '').lower() or 
                        search_lower in item.get('code', '').lower()]
            
            # Calculer la pagination
            total = len(items)
            
            # Si per_page est tr√®s grand, retourner tous les r√©sultats
            if per_page > 9999:
                return {
                    'items': items,
                    'total': total,
                    'page': 1,
                    'pages': 1,
                    'per_page': total
                }
            
            total_pages = max(1, (total + per_page - 1) // per_page)
            start_idx = (page - 1) * per_page
            end_idx = start_idx + per_page
            
            # Extraire la page
            page_items = items[start_idx:end_idx]
            
            return {
                'items': page_items,
                'total': total,
                'page': page,
                'pages': total_pages,
                'per_page': per_page,
                'restaurant_filter': restaurant_name
            }
            
        except Exception as e:
            print(f"‚ùå Erreur get_all_prices Firestore: {e}")
            return {
                'items': [],
                'total': 0,
                'page': page,
                'pages': 1,
                'per_page': per_page,
                'error': str(e)
            }
    
    def import_from_file(self, file_path: str) -> Dict[str, Any]:
        """Importer des prix depuis un fichier Excel ou CSV vers Firestore uniquement"""
        try:
            if not self._fs_enabled:
                return {
                    'total_rows': 0,
                    'new_products': 0,
                    'updated_products': 0,
                    'errors': ['Firestore non disponible']
                }
            
            # D√©terminer le type de fichier
            if file_path.endswith('.xlsx') or file_path.endswith('.xls'):
                df = pd.read_excel(file_path)
            elif file_path.endswith('.csv'):
                # Essayer diff√©rents encodages
                for encoding in ['utf-8', 'latin-1', 'iso-8859-1']:
                    try:
                        df = pd.read_csv(file_path, encoding=encoding)
                        break
                    except:
                        continue
            else:
                raise ValueError("Format de fichier non support√©")
            
            # Mapper les colonnes
            column_mapping = self._detect_column_mapping(df.columns.tolist())
            df = df.rename(columns=column_mapping)
            
            # Valider les colonnes requises
            required_columns = ['produit', 'prix']
            missing_columns = [col for col in required_columns if col not in df.columns]
            if missing_columns:
                raise ValueError(f"Colonnes manquantes: {missing_columns}")
            
            # Nettoyer et formater les donn√©es
            df = self._clean_import_data(df)
            
            # Statistiques avant import
            stats = {
                'total_rows': len(df),
                'new_products': 0,
                'updated_products': 0,
                'errors': []
            }
            
            # Traiter chaque ligne
            for _, row in df.iterrows():
                try:
                    self._import_price_row_firestore(row, stats)
                except Exception as e:
                    stats['errors'].append(f"Ligne {row.name}: {str(e)}")
            
            stats['imported'] = stats['new_products'] + stats['updated_products']
            return stats
            
        except Exception as e:
            print(f"‚ùå Erreur import fichier Firestore: {e}")
            return {
                'total_rows': 0,
                'new_products': 0,
                'updated_products': 0,
                'errors': [str(e)]
            }
    
    def _detect_column_mapping(self, columns: List[str]) -> Dict[str, str]:
        """D√©tecter automatiquement le mapping des colonnes"""
        mapping = {}
        
        # Patterns de d√©tection
        patterns = {
            'code': ['code', 'ref', 'reference', 'sku', 'article'],
            'produit': ['produit', 'product', 'libelle', 'designation', 'nom', 'article'],
            'fournisseur': ['fournisseur', 'supplier', 'vendeur', 'four'],
            'prix': ['prix', 'price', 'tarif', 'cout', 'pu', 'prix_unitaire'],
            'unite': ['unite', 'unit', 'uom', 'conditionnement'],
            'categorie': ['categorie', 'category', 'famille', 'rayon']
        }
        
        for col in columns:
            col_lower = col.lower().strip()
            for target, keywords in patterns.items():
                if any(keyword in col_lower for keyword in keywords):
                    mapping[col] = target
                    break
        
        return mapping
    
    def _clean_import_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """Nettoyer les donn√©es d'import pour Firestore"""
        try:
            # Supprimer les lignes vides
            df = df.dropna(subset=['produit'])
            
            # Nettoyer les noms de produits
            df['produit'] = df['produit'].astype(str).str.strip()
            
            # Convertir les prix en float
            df['prix'] = pd.to_numeric(df['prix'], errors='coerce').fillna(0)
            
            # Nettoyer les fournisseurs
            df['fournisseur'] = df['fournisseur'].astype(str).str.strip().fillna('UNKNOWN')
            
            # Nettoyer les unit√©s
            df['unite'] = df['unite'].astype(str).str.strip().fillna('unit√©')
            
            # Nettoyer les cat√©gories
            df['categorie'] = df['categorie'].astype(str).str.strip().fillna('Non class√©')
            
            return df
            
        except Exception as e:
            print(f"‚ùå Erreur nettoyage donn√©es: {e}")
            return df
    
    def _generate_product_code_firestore(self, product_name: str, supplier: str) -> str:
        """G√©n√©rer un code produit automatique pour Firestore"""
        try:
            # Nettoyer le nom du produit
            clean_name = ''.join(c for c in product_name.upper() if c.isalnum())[:8]
            # Nettoyer le fournisseur
            clean_supplier = ''.join(c for c in supplier.upper() if c.isalnum())[:4]
            # Ajouter timestamp
            timestamp = datetime.now().strftime('%m%d')
            
            return f"{clean_name}_{clean_supplier}_{timestamp}"
        except:
            return f"AUTO_{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    def _import_price_row_firestore(self, row: pd.Series, stats: Dict):
        """Importer une ligne de prix dans Firestore"""
        try:
            # Pr√©parer les donn√©es
            price_data = {
                'code': row.get('code', ''),
                'produit': str(row.get('produit', '')).strip(),
                'fournisseur': row.get('fournisseur', 'UNKNOWN'),
                'prix': float(row.get('prix', 0)),
                'prix_unitaire': float(row.get('prix', 0)),
                'unite': row.get('unite', 'unit√©'),
                'categorie': row.get('categorie', 'Non class√©'),
                'restaurant': row.get('restaurant', 'G√©n√©ral'),
                'date_maj': datetime.now().isoformat(),
                'actif': True
            }
            
            # G√©n√©rer un code si manquant
            if not price_data['code']:
                price_data['code'] = self._generate_product_code_firestore(price_data['produit'], price_data['fournisseur'])
            
            # V√©rifier si le produit existe d√©j√†
            existing_docs = list(self._fs.collection('prices').where('produit', '==', price_data['produit']).where('fournisseur', '==', price_data['fournisseur']).stream())
            
            if existing_docs:
                # Mettre √† jour le produit existant
                existing_docs[0].reference.update(price_data)
                stats['updated_products'] += 1
            else:
                # Ajouter nouveau produit
                self._fs.collection('prices').add(price_data)
                stats['new_products'] += 1
                
        except Exception as e:
            raise Exception(f"Erreur import ligne: {e}")
    
    def _save_prices(self):
        """M√©thode obsol√®te - Firestore uniquement"""
        print("‚ö†Ô∏è _save_prices obsol√®te - Firestore uniquement")
        pass
    
    def compare_prices(self, products: List[Dict], restaurant_name: str = None) -> Dict[str, Any]:
        """Comparer les prix des produits avec les prix de r√©f√©rence dans Firestore uniquement"""
        try:
            if not self._fs_enabled:
                return {
                    'total_products': len(products),
                    'matched_products': 0,
                    'unmatched_products': len(products),
                    'price_differences': [],
                    'missing_products': products
                }
            
            results = {
                'total_products': len(products),
                'matched_products': 0,
                'unmatched_products': 0,
                'price_differences': [],
                'missing_products': []
            }
            
            for product in products:
                product_name = product.get('produit', product.get('name', ''))
                supplier = product.get('fournisseur', product.get('supplier', ''))
                invoice_price = float(product.get('prix', product.get('price', 0)))
                
                # Chercher le prix de r√©f√©rence
                ref_price = self.find_product_price(product_name, supplier, restaurant_name)
                
                if ref_price:
                    ref_price_value = float(ref_price.get('prix', ref_price.get('prix_unitaire', 0)))
                    price_diff = invoice_price - ref_price_value
                    price_diff_percent = (price_diff / ref_price_value * 100) if ref_price_value > 0 else 0
                    
                    results['matched_products'] += 1
                    results['price_differences'].append({
                        'product': product_name,
                        'supplier': supplier,
                        'invoice_price': invoice_price,
                        'reference_price': ref_price_value,
                        'difference': price_diff,
                        'difference_percent': price_diff_percent,
                        'status': 'match'
                    })
                else:
                    results['unmatched_products'] += 1
                    results['missing_products'].append({
                        'product': product_name,
                        'supplier': supplier,
                        'invoice_price': invoice_price,
                        'status': 'missing'
                    })
            
            return results
            
        except Exception as e:
            print(f"‚ùå Erreur compare_prices Firestore: {e}")
            return {
                'total_products': len(products),
                'matched_products': 0,
                'unmatched_products': len(products),
                'price_differences': [],
                'missing_products': products,
                'error': str(e)
            }
    
    def add_pending_product_OLD(self, code: str, name: str, price: float, 
                           unit: str = 'unit√©', supplier: str = 'UNKNOWN', 
                           category: str = 'Non class√©') -> int:
        """M√©thode obsol√®te - utiliser add_pending_product avec dict"""
        print("‚ö†Ô∏è add_pending_product_OLD obsol√®te - utiliser add_pending_product")
        return 0
    
    def get_pending_products(self) -> List[Dict]:
        """R√©cup√©rer tous les produits en attente depuis Firestore uniquement"""
        try:
            if not self._fs_enabled:
                return []
            
            docs = list(self._fs.collection('pending_products').stream())
            products = []
            for doc in docs:
                data = doc.to_dict()
                data['id'] = doc.id
                products.append(data)
            
            print(f"üìä Firestore pending products: {len(products)}")
            return products
            
        except Exception as e:
            print(f"‚ùå Erreur get_pending_products Firestore: {e}")
            return []
    
    def validate_pending_product(self, pending_id: int) -> bool:
        """Valider un produit en attente (le d√©placer vers les prix valid√©s)"""
        try:
            if not self._fs_enabled:
                return False
            
            # R√©cup√©rer le produit en attente
            pending_docs = list(self._fs.collection('pending_products').where('id', '==', pending_id).stream())
            if not pending_docs:
                print(f"‚ùå Produit en attente {pending_id} non trouv√©")
                return False
            
            pending_doc = pending_docs[0]
            pending_data = pending_doc.to_dict()
            
            # Pr√©parer les donn√©es pour les prix valid√©s
            validated_data = {
                'code': pending_data.get('code', ''),
                'produit': pending_data.get('produit', ''),
                'fournisseur': pending_data.get('fournisseur', ''),
                'prix': pending_data.get('prix', 0),
                'prix_unitaire': pending_data.get('prix', 0),
                'unite': pending_data.get('unite', 'unit√©'),
                'categorie': pending_data.get('categorie', 'Non class√©'),
                'date_maj': datetime.now().isoformat(),
                'actif': True,
                'restaurant': pending_data.get('restaurant', 'G√©n√©ral')
            }
            
            # Ajouter aux prix valid√©s
            self._fs.collection('prices').add(validated_data)
            
            # Supprimer des produits en attente
            pending_doc.reference.delete()
            
            print(f"‚úÖ Produit {pending_id} valid√© et d√©plac√© vers les prix")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur validation produit Firestore: {e}")
            return False
    
    def reject_pending_product(self, pending_id: int) -> bool:
        """Rejeter un produit en attente (le supprimer)"""
        try:
            if not self._fs_enabled:
                return False
            
            # R√©cup√©rer le produit en attente
            pending_docs = list(self._fs.collection('pending_products').where('id', '==', pending_id).stream())
            if not pending_docs:
                print(f"‚ùå Produit en attente {pending_id} non trouv√©")
                return False
            
            # Supprimer le produit
            pending_docs[0].reference.delete()
            
            print(f"‚úÖ Produit {pending_id} rejet√© et supprim√©")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur rejet produit Firestore: {e}")
            return False
    
    def update_pending_product(self, pending_id: int, updates: Dict) -> bool:
        """Mettre √† jour un produit en attente"""
        try:
            if not self._fs_enabled:
                return False
            
            # R√©cup√©rer le produit en attente
            pending_docs = list(self._fs.collection('pending_products').where('id', '==', pending_id).stream())
            if not pending_docs:
                print(f"‚ùå Produit en attente {pending_id} non trouv√©")
                return False
            
            # Mettre √† jour le produit
            updates['date_maj'] = datetime.now().isoformat()
            pending_docs[0].reference.update(updates)
            
            print(f"‚úÖ Produit {pending_id} mis √† jour")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur mise √† jour produit Firestore: {e}")
            return False
    
    def add_pending_product(self, product_data: Dict) -> bool:
        """Ajouter un produit en attente dans Firestore uniquement"""
        try:
            if not self._fs_enabled:
                return False
            
            # G√©n√©rer un ID unique
            product_data['id'] = int(datetime.now().timestamp() * 1000)
            product_data['date_ajout'] = datetime.now().isoformat()
            product_data['status'] = 'pending'
            
            # Ajouter √† Firestore
            self._fs.collection('pending_products').add(product_data)
            
            print(f"‚úÖ Produit en attente ajout√©: {product_data.get('produit', '')}")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur ajout produit en attente Firestore: {e}")
            return False
    
    def _generate_pending_code(self, name: str, supplier: str) -> str:
        """G√©n√©rer un code pour un produit en attente"""
        # Prendre les 3 premi√®res lettres du nom et fournisseur
        name_part = ''.join(c for c in name[:3] if c.isalnum()).upper()
        supplier_part = ''.join(c for c in supplier[:3] if c.isalnum()).upper()
        
        # Ajouter timestamp
        timestamp = datetime.now().strftime('%m%d')
        
        return f"P{supplier_part}{name_part}{timestamp}"

    # ===== NOUVELLE M√âTHODE ANTI-DOUBLON =====
    def _product_exists(self, name: str, supplier: str, restaurant: str = 'G√©n√©ral') -> bool:
        """V√©rifier si un produit existe d√©j√† dans la base confirm√©e (nom + fournisseur + restaurant)"""
        try:
            if not self._fs_enabled:
                return False
            query = self._fs.collection('prices').where('produit', '==', name).where('fournisseur', '==', supplier).where('restaurant', '==', restaurant)
            docs = list(query.stream())
            return bool(docs)
        except Exception:
            return False
    
    def add_confirmed_product_directly(self, product_data: Dict) -> bool:
        """
        ‚ö†Ô∏è FONCTION D√âSACTIV√âE - Utiliser add_pending_product √† la place
        Cette fonction cr√©ait des produits valid√©s automatiquement, ce qui causait des probl√®mes
        """
        print(f"‚ö†Ô∏è ADD_CONFIRMED: Fonction d√©sactiv√©e - utiliser add_pending_product")
        return False

    def add_price(self, price_data: Dict) -> bool:
        """Ajouter un prix valid√© dans Firestore uniquement"""
        try:
            if not self._fs_enabled:
                return False
            
            # Ajouter les m√©tadonn√©es
            price_data['date_maj'] = datetime.now().isoformat()
            price_data['actif'] = True
            
            # Ajouter √† Firestore
            self._fs.collection('prices').add(price_data)
            
            print(f"‚úÖ Prix ajout√©: {price_data.get('produit', '')}")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur ajout prix Firestore: {e}")
            return False
    
    def update_price(self, code: str, updates: Dict) -> bool:
        """Mettre √† jour un prix dans Firestore uniquement"""
        try:
            if not self._fs_enabled:
                return False
            
            # Chercher le prix par code
            docs = list(self._fs.collection('prices').where('code', '==', code).stream())
            if not docs:
                print(f"‚ùå Prix avec code {code} non trouv√©")
                return False
            
            # Mettre √† jour
            updates['date_maj'] = datetime.now().isoformat()
            docs[0].reference.update(updates)
            
            print(f"‚úÖ Prix {code} mis √† jour")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur mise √† jour prix Firestore: {e}")
            return False
    
    def update_price_by_id(self, price_id: int, updates: Dict) -> bool:
        """Mettre √† jour un prix par ID dans Firestore uniquement"""
        try:
            if not self._fs_enabled:
                return False
            
            # Chercher le prix par ID
            docs = list(self._fs.collection('prices').where('id', '==', price_id).stream())
            if not docs:
                print(f"‚ùå Prix avec ID {price_id} non trouv√©")
                return False
            
            # Mettre √† jour
            updates['date_maj'] = datetime.now().isoformat()
            docs[0].reference.update(updates)
            
            print(f"‚úÖ Prix {price_id} mis √† jour")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur mise √† jour prix Firestore: {e}")
            return False
    
    def delete_price(self, code: str) -> bool:
        """Supprimer un prix par code dans Firestore uniquement"""
        try:
            if not self._fs_enabled:
                return False
            
            # Chercher le prix par code
            docs = list(self._fs.collection('prices').where('code', '==', code).stream())
            if not docs:
                print(f"‚ùå Prix avec code {code} non trouv√©")
                return False
            
            # Supprimer
            docs[0].reference.delete()
            
            print(f"‚úÖ Prix {code} supprim√©")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur suppression prix Firestore: {e}")
            return False
    
    def delete_price_by_id(self, price_id: int) -> bool:
        """Supprimer un prix par ID dans Firestore uniquement"""
        try:
            if not self._fs_enabled:
                return False
            
            # Chercher le prix par ID
            docs = list(self._fs.collection('prices').where('id', '==', price_id).stream())
            if not docs:
                print(f"‚ùå Prix avec ID {price_id} non trouv√©")
                return False
            
            # Supprimer
            docs[0].reference.delete()
            
            print(f"‚úÖ Prix {price_id} supprim√©")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur suppression prix Firestore: {e}")
            return False
    
    def delete_price_cascade(self, price_id: int) -> Dict[str, Any]:
        """Supprimer un prix et tous ses produits associ√©s dans Firestore uniquement"""
        try:
            if not self._fs_enabled:
                return {
                    'success': False,
                    'error': 'Firestore non disponible',
                    'deleted_price': False,
                    'deleted_products': 0
                }
            
            # Chercher le prix par ID
            docs = list(self._fs.collection('prices').where('id', '==', price_id).stream())
            if not docs:
                return {
                    'success': False,
                    'error': f'Prix avec ID {price_id} non trouv√©',
                    'deleted_price': False,
                    'deleted_products': 0
                }
            
            price_doc = docs[0]
            price_data = price_doc.to_dict()
            
            # Supprimer le prix
            price_doc.reference.delete()
            
            # Supprimer les produits en attente associ√©s
            pending_docs = list(self._fs.collection('pending_products').where('produit', '==', price_data.get('produit', '')).stream())
            for doc in pending_docs:
                doc.reference.delete()
            
            result = {
                'success': True,
                'deleted_price': True,
                'deleted_products': len(pending_docs),
                'price_id': price_id
            }
            
            print(f"‚úÖ Prix {price_id} et {len(pending_docs)} produits associ√©s supprim√©s")
            return result
            
        except Exception as e:
            print(f"‚ùå Erreur suppression prix cascade Firestore: {e}")
            return {
                'success': False,
                'error': str(e),
                'deleted_price': False,
                'deleted_products': 0
            }
    
    def get_suppliers(self) -> List[str]:
        """R√©cup√©rer la liste des fournisseurs depuis Firestore uniquement"""
        try:
            if not self._fs_enabled:
                return []
            
            # R√©cup√©rer tous les prix
            docs = list(self._fs.collection('prices').stream())
            suppliers = set()
            
            for doc in docs:
                data = doc.to_dict()
                if data.get('fournisseur'):
                    suppliers.add(data['fournisseur'])
            
            suppliers_list = list(suppliers)
            suppliers_list.sort()
            
            print(f"üìä Firestore suppliers: {len(suppliers_list)}")
            return suppliers_list
            
        except Exception as e:
            print(f"‚ùå Erreur get_suppliers Firestore: {e}")
            return []
    
    def get_prices_by_suppliers(self, supplier_names: List[str]) -> List[Dict[str, Any]]:
        """R√©cup√©rer les prix par fournisseurs depuis Firestore uniquement"""
        try:
            if not self._fs_enabled:
                return []
            
            all_prices = []
            
            for supplier in supplier_names:
                docs = list(self._fs.collection('prices').where('fournisseur', '==', supplier).stream())
                for doc in docs:
                    data = doc.to_dict()
                    data['id'] = doc.id
                    all_prices.append(data)
            
            print(f"üìä Firestore prices by suppliers: {len(all_prices)}")
            return all_prices
            
        except Exception as e:
            print(f"‚ùå Erreur get_prices_by_suppliers Firestore: {e}")
            return []
    
    def find_product_price(self, product_name: str, supplier: str = '', restaurant: str = 'G√©n√©ral') -> Optional[Dict]:
        """Trouver un prix de produit dans Firestore uniquement"""
        try:
            if not self._fs_enabled:
                return None
            
            # Construire la requ√™te
            query = self._fs.collection('prices').where('produit', '==', product_name)
            
            if supplier:
                query = query.where('fournisseur', '==', supplier)
            
            docs = list(query.stream())
            
            if not docs:
                return None
            
            # Si plusieurs r√©sultats, filtrer par restaurant
            if len(docs) > 1 and restaurant:
                filtered_docs = []
                for doc in docs:
                    data = doc.to_dict()
                    if data.get('restaurant') == restaurant or data.get('restaurant') == 'G√©n√©ral':
                        filtered_docs.append(doc)
                docs = filtered_docs
            
            if docs:
                data = docs[0].to_dict()
                data['id'] = docs[0].id
                return data
            
            return None
            
        except Exception as e:
            print(f"‚ùå Erreur find_product_price Firestore: {e}")
            return None 